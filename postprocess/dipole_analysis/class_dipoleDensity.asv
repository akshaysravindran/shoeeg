classdef class_dipoleDensity
    % for plotting dipole density from STUDY file
    %   Usage:
    %       dipden_obj = class_dipoleDensity('inputStudy',STUDY,'inputEEG',ALLEEG);
    %       process(dipden_obj);
    %
    %   Arguments:
    %       'inputStudy': STUDY structure made before running this (required)
    %       'inputEEG': ALLEEG structure made at the same time as STUDY
    %
    %   Options (for more info go to reference at the bottom):
    %       'which_clust': which cluster you want to show as dipole
    %                      density? [default: 2] (which is Parent cluster)
    %                      this depends on your STUDY.cluster structure.
    %                      If you have outliers, 4 should be the first
    %                      cluster. If you don't have outliers, then 3
    %                      should be the first cluster.
    %
    %       'which_group': which group you want to plot. [default: 2]
    %                      (which is all) this also depends on your
    %                      structure. Please check.
    %
    %       'dipole_color': what color do you want for your dipole?
    %                       [default: [1,0,0]] (which is Red)
    %
    %       'dipole_color_name': what is the name of the color?
    %                            [default: 'Red']
    %
    %       'slice_orientation': 1 = Axial (default), 2 = sagittal, 3 =
    %                            coronal
    %
    %       'gauss_smooth_sigma': Gaussian smoothing sigma in mm scale.
    %                             [default: 14.2]. This will be converted to
    %                             FWHM = 2.355 * sigma. For more
    %                             information, https://en.wikipedia.org/wiki/Full_width_at_half_maximum
    %
    %       'color_upper_limit': Color scale upper limit. [default: []]
    %
    %       'group_subtractor': 1 = none (default), 2 = all
    %
    %       'group_subtracted': 1 = none (default), 2 = all
    %
    %       'threshold_pval': Used for group analysis [default: 5] (%)
    %
    %   Pre-requisites:
    %       EEGLAB: https://sccn.ucsd.edu/eeglab/
    %       std_dipoleDensity: https://sccn.ucsd.edu/wiki/DipoleDensity
    
    % Copyright (C) 2017 Sho Nakagome (snakagome@uh.edu)
    %               2012 Makoto Miyakoshi (original program)
    %
    %     This program is free software: you can redistribute it and/or modify
    %     it under the terms of the GNU General Public License as published by
    %     the Free Software Foundation, either version 3 of the License, or
    %     (at your option) any later version.
    %
    %     This program is distributed in the hope that it will be useful,
    %     but WITHOUT ANY WARRANTY; without even the implied warranty of
    %     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    %     GNU General Public License for more details.
    %
    %     You should have received a copy of the GNU General Public License
    %     along with this program.  If not, see <http://www.gnu.org/licenses/>.
    
    properties
        inputSTUDY;
        inputALLEEG;
        
        % for Dipole Density parameters
        which_clust;
        which_group;
        dipole_color;
        dipole_color_name;
        slice_orientation;
        gauss_smooth_sigma;
        color_upper_limit;
        group_subtractor;
        group_subtracted;
        threshold_pval;
    end
    
    methods (Access = public)
        % defining a constructor
        function obj = class_dipoleDensity(varargin)
            % add path to dependencies (need this for
            % std_groupDipSeparator)
            if ispc == 1
                sep = '\';
            elseif isunix == 1
                sep = '/';
            end
            addpath(['..',sep,'dependencies']);
            % make sure to addpath to eeglab as well
            
            % input STUDY
            obj.inputSTUDY = get_varargin(varargin,'inputSTUDY',[]);
            % input ALLEEG
            obj.inputALLEEG = get_varargin(varargin,'inputEEG',[]);
            
            % check errors (need the above inputs)
            [obj.inputSTUDY, obj.inputALLEEG] = ...
                std_checkset(obj.inputSTUDY, obj.inputALLEEG);
            
            % ===== Other parameters for Dipole Density =====
            obj.which_clust = get_varargin(varargin,'which_clust',2);
            obj.which_group = get_varargin(varargin,'which_group',2);
            obj.dipole_color = get_varargin(varargin,'dipole_color',[1,0,0]);
            obj.dipole_color_name = get_varargin(varargin,'dipole_color_name','Red');
            obj.slice_orientation = get_varargin(varargin,'slice_orientation',1);
            obj.gauss_smooth_sigma = get_varargin(varargin,'gauss_smooth_sigma',14.2);
            obj.color_upper_limit = get_varargin(varargin,'color_upper_limit',[]);
            obj.group_subtractor = get_varargin(varargin,'group_subtractor',1);
            obj.group_subtracted = get_varargin(varargin,'group_substracted',1);
            obj.threshold_pval = get_varargin(varargin,'threshold_pval',5);
            % ===============================================
            
            % put the parameters into a structure
            obj.plotParams{1,1}.cluster = obj.which_clust;
            obj.plotParams{1,1}.group = obj.which_group;
            obj.plotParams{1,1}.color = obj.dipole_color;
            obj.plotParams{1,1}.colorName = obj.dipole_color_name;
            % just assingn 1 to the rest since we are not plotting
            for i = 1:4
                obj.plotParams{1,1+i}.cluster = 1;
                obj.plotParams{1,1+i}.group = 1;
            end
            obj.plotParams{1,6} = obj.slice_orientation;
            obj.plotParams{1,7} = obj.gauss_smooth_sigma/2.355;
            obj.plotParams{1,8} = obj.color_upper_limit;
            obj.plotParams{1,9} = obj.group_subtractor;
            obj.plotParams{1,10} = obj.group_subtracted;
            obj.plotParams{1,11} = obj.threshold_pval;
            obj.plotParams{1,12} = 0; % for saving figures
        end
    end
    
    methods
        % if you just want to run normally
        function process(obj)
            % run std_dipoleDensity to get all the plots
            std_dipoleDensity(obj.inputSTUDY, obj.inputALLEEG, obj.plotParams)
        end
        
        % if you want to plot slices only
        function sliceplot(obj)
            % define temporal parameters
            currentDesign = obj.inputSTUDY.currentdesign;
            designLabel = {obj.inputSTUDY.design(currentDesign).variable.label};
            groupFieldIdx = find(strcmp(designLabel, 'group')|strcmp(designLabel, 'session')); % find the slot index that has 'group' or 'session'
            if isempty(groupFieldIdx) % no 'group'
                singletonFieldIdx = find(size(obj.inputSTUDY.cluster(1,2).setinds)==1); % find the slot that is NOT the within-subject condition
                if length(singletonFieldIdx)>1 % this means both var1 and var2 are empty
                    singletonFieldIdx = 1;
                end
                groupFieldIdx = singletonFieldIdx;
            end
            tmpCluster   = obj.plotParams{1,1}.cluster-1;
            tmpGroup     = obj.plotParams{1,1}.group;
            tmpColor     = obj.plotParams{1,1}.color;
            tmpColorName = obj.plotParams{1,1}.colorName;
            
            % separate groups
            obj.inputSTUDY = std_groupDipSeparator(obj.inputSTUDY, ...
                obj.inputALLEEG, tmpCluster);
            
            % select specific/all groups
            if tmpGroup == 2 % show all groups
                tmpGroupName = 'all';
                source  = struct([]);
                dipName = [];
                for numGroups = 1:length(obj.inputSTUDY.design(currentDesign).variable(1,groupFieldIdx).value)
                    source    = [source obj.inputSTUDY.cluster(1,tmpCluster).groupDipModels{1,numGroups}];
                    dipName   = [dipName obj.inputSTUDY.cluster(1,tmpCluster).groupDipNames{1,numGroups}];
                end
            else % selecting a group
                tmpGroupName = obj.inputSTUDY.design(currentDesign).variable(1,groupFieldIdx).value{1,tmpGroup-2};
                source  = obj.inputSTUDY.cluster(1,tmpCluster).groupDipModels{1,tmpGroup-2};
                dipName = obj.inputSTUDY.cluster(1,tmpCluster).groupDipNames{1,tmpGroup-2};
            end
            
            % add centroid in the end
            centroid = computecentroid(source);
            source(end + 1) = centroid;
            centroidTal = mni2tal(centroid.posxyz);
            
            % Determine which side of dipoles should be taken if bilateral dipoles are present.
            % Note that in source.posxyz, (1,:) is always positive (i.e. right hand side) and (2,:) is always negative (i.e. left hand side)
            if sign(centroid.posxyz(1)) > 0
                leftOrRightDipoleChoice = 1;
            else
                leftOrRightDipoleChoice = 2;
            end
            
            % Identify the two-dipole fit cases, and choose the side of dipoles that is consistent with cluster centroid.
            tmpSource = source;
            for sourceIdx = 1:length(tmpSource)
                if size(tmpSource(sourceIdx).posxyz,1) == 2
                    tmpSource(sourceIdx).posxyz = tmpSource(sourceIdx).posxyz(leftOrRightDipoleChoice,:);
                end
            end
            coordinateTable = cell2mat({tmpSource.posxyz}');
            coordinateTable = coordinateTable(1:end-1,:); % Exclude centroid
            standardDeviation = std(coordinateTable);
            standardError     = std(coordinateTable)/sqrt(size(coordinateTable,1));
            clusterReport     = sprintf('\nCluster: %.0f\nCentroid in MNI:    [%2.0f %2.0f %2.0f]\nStandard Deviation: [%2.0f %2.0f %2.0f]\nStandard Error    : [%2.0f %2.0f %2.0f]\n',...
                tmpCluster,...
                centroid.posxyz(1),   centroid.posxyz(2),   centroid.posxyz(3), ...
                standardDeviation(1), standardDeviation(2), standardDeviation(3),...
                standardError(1),     standardError(2),     standardError(3));
            
            % prepare colors
            dipColor = cell(1, length(source));
            dipColor(1:length(source)-1) = {tmpColor};
            dipColor(end) = {[1 0 0]};
            
            % prepare names
            centroidName = [obj.inputSTUDY.cluster(1,tmpCluster).name ' mean'];
            dipName = [dipName centroidName];
            
            % plotting dipoledensity
            customJet = jet(128);
            customJet(1,:)=0.3; % this is to make the background black
            if isempty(obj.plotParams{1,8})
                cmin = 0;
                cmax = [];
            else
                cmin = obj.plotParams{1,8}(1);
                cmax = obj.plotParams{1,8}(2);
            end
            
            if     obj.plotParams{1,6} == 1; % axial
                plotargs = {'mriview', 'top',  'mrislices', -30:10:70, 'cmap', customJet, 'mixfact', 0.65, 'cmin', cmin, 'cmax', cmax};
            elseif obj.plotParams{1,6} == 2; % sagittal
                plotargs = {'mriview', 'side', 'mrislices', -70:10:70, 'cmap', customJet, 'mixfact', 0.65, 'cmin', cmin, 'cmax', cmax};
            elseif obj.plotParams{1,6} == 3; % coronal
                plotargs = {'mriview', 'rear', 'mrislices', -90:10:60, 'cmap', customJet, 'mixfact', 0.65, 'cmin', cmin, 'cmax', cmax};
            end
            
            [dens3d mri] = dipoledensity(source, ...
                'coordformat', obj.inputALLEEG(1,1).dipfit.coordformat, ...
                'methodparam', obj.plotParams{1,7}, 'plot', 'off', ...
                'norm2JointProb', 'on', 'plotargs', plotargs);
            
            allGroupDens3d{tmpGroup} = dens3d;
            
            % perform subtraction
            tmpDiff = allGroupDens3d{1,obj.plotParams{1,9}}{1,1} - ...
                allGroupDens3d{1,obj.plotParams{1,10}}{1,1};
            
            % mask outside brain
            tmpDiff(tmpDiff==0) = NaN;
            
            % color bar range
            if abs(max(tmpDiff(:)))>abs(min(tmpDiff(:)))
                cmax = 2*abs(max(tmpDiff(:)));
                yTickLabel = linspace(-abs(max(tmpDiff(:))), ...
                    abs(max(tmpDiff(:))), 5);
                yTickLabel = round(yTickLabel*1000000)/1000000;
            else
                cmax = 2*abs(min(min(min(tmpDiff))));
                yTickLabel = linspace(-abs(min(tmpDiff(:))), ...
                    abs(min(tmpDiff(:))), 5);
                yTickLabel = round(yTickLabel*1000000)/1000000;
            end
            
            % threshold
            tmpDiffSort = sort(tmpDiff(:));
            tmpDiffSort(isnan(tmpDiffSort))=[];
            leftCut  = tmpDiffSort(round(length(tmpDiffSort)*plotParams{1,11}/2/100));
            rightCut = tmpDiffSort(round(length(tmpDiffSort)*(1-plotParams{1,11}/2/100)));
            leftSide = tmpDiff;
            leftSide(leftSide>leftCut) = 0;
            rightSide = tmpDiff;
            rightSide(rightSide<rightCut) = 0;
            tmpDiffMasked = leftSide + rightSide;
            tmpDiffMasked(tmpDiffMasked==0) = NaN;
            minColorResolution = (abs(max(tmpDiffMasked(:))) + abs(min(tmpDiffMasked(:))))/127; % this is to avoid 0 that is for non-significant regions
            tmpDiffMasked = tmpDiffMasked - min(tmpDiffMasked(:)) + minColorResolution;
            tmpDiffMasked = {tmpDiffMasked};
            
            % actual plot
            mri3dplot(tmpDiffMasked, mri, plotargs{:}, 'cmax', cmax, 'mixfact', 0.45)
        end
    end
    
    methods (Access = private)
        % defining a destructor
        function delete(obj)
            % Delete object
        end
    end
    
end

